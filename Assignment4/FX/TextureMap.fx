/*
*	Vincent Loignon and Tyler Cifelli
*	Assignment 3
*	TextureMap.fx
*	I certify that this assignment is entirely our own work.
*
* Side Note: We worked on the algorithm for calculating the lighting together basing it
*			 off of Frank Luna's lighting chapter and other outside influence (cited in the
			 comments). The implementation afterwards was all based off the same algorithm.
*/

uniform extern texture gTexture;
sampler TextureSampler = sampler_state
{
      Texture = <gTexture>;
      MinFilter = LINEAR;
      MagFilter = LINEAR;
};

uniform extern float4x4 gWorld;
uniform extern float4x4 gWorldInvTrans;
uniform extern float4x4 gWVP;

uniform extern float3 gEyePos;
uniform extern float3 gLightVec;
uniform extern float4 gColor;

uniform extern float4 gDiffuseColor;
uniform extern float4 gSpecularColor;
uniform extern float gSpecularPower;

uniform extern bool gUseTexture;

float4 gAmbientColor = float4(0.2f, 0.2f, 0.2f, 1.0f);
float4 gAmbientLight = float4(0.4f, 0.4f, 0.4f, 0.4f);
float4 gDiffuseLight = float4(1.0f, 1.0f, 1.0f, 1.0f);
float4 gSpecularLight = float4(1.0f, 1.0f, 1.0f, 1.0f);

float gAmbientBlend = float(0.2f);
float gDiffuseBlend = float(0.65f);
float gSpecularBlend = float(0.15f);

struct InputVS
{
	float3 Position : POSITION0;
	float3 Normal : NORMAL0;
	float2 TexCoord : TEXCOORD0;
};

struct OutputVS_GOURAUD
{
	float4 Position : POSITION0;
	float4 Diffuse  : COLOR0;
	float4 Specular : COLOR1;
	float2 TexCoord : TEXCOORD0;
};

struct OutputVS_PHONG
{
	float4 Position    : POSITION0;
	float3 Normal	   : TEXCOORD0;
	float3 WorldPos    : TEXCOORD1;
	float2 TexCoord    : TEXCOORD2;
};

// Phong shading done by Tyler Cifelli
// With the aid from frank luna's examples
OutputVS_PHONG TexturePhongVS(InputVS input)
{
	OutputVS_PHONG outVS = (OutputVS_PHONG)0;

	// Transform our normal into world space
	outVS.Normal = mul(float4(input.Normal, 0.0f), gWorldInvTrans).xyz;
	outVS.Normal = normalize(outVS.Normal);

	// Transform our vertex into world space
	outVS.WorldPos = mul(float4(input.Position, 1.0f), gWorld).xyz;

	// Transform our vertex into homogenous space
	outVS.Position = mul(float4(input.Position, 1.0f), gWVP);
	outVS.TexCoord = input.TexCoord;

	return outVS;
}

float4 TexturePhongPS(OutputVS_PHONG input) : COLOR
{
	// Renormalize our normal just to be safe
	float3 normal = normalize(input.Normal);

	float3 lightVec = normalize(gLightVec);

	// Calculate our eye (view) vector and normalize it
	float3 eyeVec = normalize(gEyePos - input.WorldPos);

	// Calculate the reflection vector from the light vector
	float3 reflectVec = reflect(-lightVec, normal);

	float3 specular = 0.0f;

	// Calculate our specular coloring
  float t = pow(max(dot(reflectVec, eyeVec), 0.0f), gSpecularPower);
  specular = t * (gSpecularColor * gSpecularLight).rgb;

	// Calculate the ambient coloring
	float3 ambient = gAmbientColor * gAmbientLight;

	float3 diffuse = 0.0f;

	// Calculate our diffuse coloring
	float s = max(dot(lightVec, normal), 0.0f);

	// Thanks to Kyle Strader here for a tip on improving diffuse!
	diffuse = s * (gDiffuseLight).rgb;
	diffuse = (diffuse + ambient);

	if (gUseTexture)
	{
		float3 texColor = tex2D(TextureSampler, input.TexCoord).rgb;

		// Combine texture color with color generated by lighting.
		diffuse *= texColor;
	}
	else
		diffuse *= gColor;

	return float4(ambient + diffuse + specular, gDiffuseColor.a);
}

// Gouraud shading done by Vincent Loignon
// Also with help from frank luna's examples
OutputVS_GOURAUD TextureGouraudVS(InputVS input)
{
	OutputVS_GOURAUD outVS = (OutputVS_GOURAUD)0;

	// Transform our normal into world space
	float3 normal = mul(float4(input.Normal, 0.0f), gWorldInvTrans).xyz;
	normal = normalize(normal);

	// Transform our vertex into world space
	float3 worldPos = mul(float4(input.Position, 1.0f), gWorld).xyz;

	// Transform our vertex into homogenous space
	outVS.Position = mul(float4(input.Position, 1.0f), gWVP);

	float3 lightVec = normalize(gLightVec);

	// Calculate our eye (view) vector and normalize it
	float3 eyeVec = normalize(gEyePos - worldPos);

	// Calculate the reflection vector from the light vector
	float3 reflectVec = reflect(-lightVec, normal);

	// Calculate the ambient coloring
	float3 ambient = gAmbientColor * gAmbientLight;

	float3 specular = 0.0f;
	float3 diffuse = 0.0f;

	// Calculate our specular coloring
	float t = pow(max(dot(reflectVec, eyeVec), 0.0f), gSpecularPower);
	specular = t * (gSpecularColor * gSpecularLight).rgb;

	// Calculate our diffuse coloring
	float s = max(dot(lightVec, normal), 0.0f);

	// Thanks to Kyle Strader here for a tip on improving diffuse!
	diffuse = s * (gDiffuseLight).rgb;
	diffuse = (diffuse + ambient);

	// Sum all the terms together and copy over the diffuse alpha.
	outVS.Diffuse = float4(diffuse, gDiffuseColor.a);
	outVS.Specular = float4(specular, 0.0f);
	outVS.TexCoord = input.TexCoord;

	return outVS;
}

float4 TextureGouraudPS(OutputVS_GOURAUD input) : COLOR
{
	float3 diffuse = input.Diffuse.rgb;

	// Combine texture color with color generated by lighting.
	if (gUseTexture)
	{
		float3 texColor = tex2D(TextureSampler, input.TexCoord).rgb;

		diffuse *= texColor;
	}
	else
		diffuse *= gColor;

	// Add in the specular term separately.
	return float4(diffuse + input.Specular.rgb, input.Diffuse.a);
}

technique PhongTech
{
	pass P0
	{
		VertexShader = compile vs_2_0 TexturePhongVS();
		PixelShader = compile ps_2_0 TexturePhongPS();
	}
};

technique GouraudTech
{
	pass P0
	{
		VertexShader = compile vs_2_0 TextureGouraudVS();
		PixelShader = compile ps_2_0 TextureGouraudPS();
	}
};
